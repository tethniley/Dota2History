<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>My Dota Match History</title>
  <style>
    :root {
      --bg: #1b2838;
      --card: #2a475e;
      --card-hover: #3b6b8e;
      --accent: #66c0f4;
      --text: #ffffff;
      --win: #2ecc71;
      --loss: #e74c3c;
      --muted: #e6e6e6;
    }
    * { box-sizing: border-box; }
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: var(--bg);
      color: var(--text);
      margin: 0;
      padding: 20px;
    }
    h2 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 28px;
      color: var(--accent);
    }
    #match-container {
      max-width: 900px;
      margin: auto;
      height: 520px;                /* scrollable viewport */
      overflow-y: auto;
      position: relative;
      padding-bottom: 80px;         /* space for fade overlay */
      border-radius: 10px;
    }
    ul { list-style: none; padding: 0; margin: 0; }
    li {
      background: var(--card);
      margin: 10px 0;
      padding: 12px;
      border-radius: 10px;
      display: grid;
      grid-template-columns: 72px 1fr auto;
      align-items: center;
      gap: 12px;
      transition: transform 0.2s ease, background 0.2s ease;
    }
    li:hover { transform: translateY(-2px); background: var(--card-hover); }
    img { border-radius: 8px; width: 60px; height: 34px; object-fit: cover; }
    a { color: var(--accent); font-weight: 600; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .match-info { display: flex; flex-direction: column; gap: 2px; }
    .meta { font-size: 12px; color: var(--muted); }
    .kda { font-size: 14px; color: #f4f4f4; }
    .badge {
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 700;
      font-size: 12px;
      letter-spacing: 0.4px;
      text-transform: uppercase;
      text-align: center;
      min-width: 84px;
    }
    .badge.win { background: rgba(46, 204, 113, 0.15); color: var(--win); border: 1px solid rgba(46,204,113,0.4); }
    .badge.loss { background: rgba(231, 76, 60, 0.15); color: var(--loss); border: 1px solid rgba(231,76,60,0.4); }
    .side { font-size: 11px; opacity: 0.85; text-align: center; margin-top: 4px; }

    /* Fading overlay to hint more content */
    #fade-overlay {
      position: absolute; bottom: 0; left: 0; right: 0; height: 90px;
      background: linear-gradient(to top, rgba(27,40,56,0.98) 30%, rgba(27,40,56,0) 100%);
      pointer-events: none;
    }

    /* Load More button */
    #load-more {
      display: block;
      margin: 16px auto;
      padding: 10px 20px;
      background: rgba(102,192,244,0.9);
      color: var(--bg);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 800;
      transition: background 0.2s ease, transform 0.1s ease;
    }
    /* --- NEW: controls + pager + skeletons --- */
#controls {
  max-width: 900px;
  margin: 0 auto 14px auto;
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
}
#controls select {
  background: rgba(255,255,255,0.06);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 8px;
  padding: 8px 10px;
}
#pager {
  margin-left: auto;
  font-size: 13px;
  opacity: 0.9;
}

#load-more[disabled] {
  opacity: 0.6;
  cursor: not-allowed;
}

.skeleton {
  background: var(--card);
  border-radius: 10px;
  padding: 12px;
  margin: 10px 0;
  display: grid;
  grid-template-columns: 72px 1fr auto;
  gap: 12px;
}
.skel-img, .skel-line, .skel-badge {
  position: relative;
  overflow: hidden;
  border-radius: 8px;
  background: rgba(255,255,255,0.08);
}
.skel-img { width: 60px; height: 34px; }
.skel-line { height: 12px; border-radius: 6px; }
.skel-line.wide { width: 70%; }
.skel-line.mid  { width: 50%; margin-top: 6px; }
.skel-line.narrow { width: 30%; margin-top: 6px; }
.skel-badge { width: 84px; height: 26px; border-radius: 999px; }

@keyframes shimmer {
  0% { background-position: -200px 0; }
  100% { background-position: 200px 0; }
}
.skeleton .skel-img,
.skeleton .skel-line,
.skeleton .skel-badge {
  background-image: linear-gradient(
    90deg,
    rgba(255,255,255,0.06) 25%,
    rgba(255,255,255,0.15) 37%,
    rgba(255,255,255,0.06) 63%
  );
  background-size: 400px 100%;
  animation: shimmer 1.2s infinite;
}

    #load-more:hover { background: rgba(102,192,244,1); }
    #load-more:active { transform: translateY(1px); }
  </style>
  </head>
<body>
  <h2>Dota Match History</h2>
  <div id="controls">
  <select id="hero-filter">
    <option value="">All Heroes</option>
  </select>

  <select id="result-filter">
    <option value="">All Results</option>
    <option value="win">Wins</option>
    <option value="loss">Losses</option>
  </select>

  <span id="pager">
    Loaded: <strong id="loaded-count">0</strong> &nbsp;|&nbsp;
    Page: <strong id="page-num">1</strong>
  </span>
</div>

  <div id="match-container">
    <ul id="matches">Loading...</ul>
    <div id="fade-overlay"></div>
  </div>

  <button id="load-more">Load More</button>

  <script>
  const accountId = 254022844; // your Steam32
  const limit = 10;

  // State
  let offset = 0;
  let page = 1;
  let allMatches = [];
  let heroes = [];
  let heroById = {};
  let heroImgById = {};
  let isLoading = false;

  // Elements
  const $matches = document.getElementById("matches");
  const $loadMore = document.getElementById("load-more");
  const $loadedCount = document.getElementById("loaded-count");
  const $pageNum = document.getElementById("page-num");
  const $heroFilter = document.getElementById("hero-filter");
  const $resultFilter = document.getElementById("result-filter");
  const $container = document.getElementById("match-container");

  // Utilities
  function fmtMins(seconds) { return `${Math.round(seconds / 60)} min`; }
  function toDateStr(start_time) {
    const d = new Date(start_time * 1000);
    return d.toLocaleString([], { year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute:'2-digit' });
  }
  function isWin(match) {
    const youRadiant = match.player_slot < 128;
    const radiantWin = match.radiant_win;
    return (youRadiant && radiantWin) || (!youRadiant && !radiantWin);
  }
  function sideLabel(slot) { return slot < 128 ? "Radiant" : "Dire"; }

  // Skeletons
  function showSkeletons(count = 5) {
    const skels = Array.from({ length: count }).map(() => `
      <li class="skeleton">
        <div class="skel-img"></div>
        <div>
          <div class="skel-line wide"></div>
          <div class="skel-line mid"></div>
          <div class="skel-line narrow"></div>
        </div>
        <div class="skel-badge"></div>
      </li>
    `).join("");
    $matches.insertAdjacentHTML("beforeend", skels);
  }
  function clearSkeletons() {
    [...$matches.querySelectorAll(".skeleton")].forEach(n => n.remove());
  }

  // Fetchers
  async function fetchHeroesOnce() {
    if (heroes.length) return heroes;
    heroes = await fetch("https://api.opendota.com/api/heroes").then(r => r.json());
    heroById = Object.fromEntries(heroes.map(h => [h.id, h.localized_name]));
    heroImgById = Object.fromEntries(heroes.map(h => [h.id, h.name.replace("npc_dota_hero_", "")]));

    // Populate hero filter
    const opts = heroes
      .sort((a,b) => a.localized_name.localeCompare(b.localized_name))
      .map(h => `<option value="${h.id}">${h.localized_name}</option>`).join("");
    $heroFilter.insertAdjacentHTML("beforeend", opts);
    return heroes;
  }

  async function fetchMatchesChunk(off) {
    const url = `https://api.opendota.com/api/players/${accountId}/matches?limit=${limit}&offset=${off}`;
    const r = await fetch(url);
    return r.json();
  }

  // Rendering
  function render() {
    // Apply filters to allMatches
    const heroFilterVal = $heroFilter.value;
    const resultFilterVal = $resultFilter.value; // '', 'win', 'loss'

    const filtered = allMatches.filter(m => {
      const passHero = heroFilterVal ? String(m.hero_id) === heroFilterVal : true;
      const passResult = resultFilterVal
        ? (resultFilterVal === 'win' ? isWin(m) : !isWin(m))
        : true;
      return passHero && passResult;
    });

    // Rebuild list
    $matches.innerHTML = filtered.map(m => {
      const win = isWin(m);
      return `
        <li>
          <img src="https://cdn.cloudflare.steamstatic.com/apps/dota2/images/dota_react/heroes/${heroImgById[m.hero_id]}.png"
               alt="${heroById[m.hero_id] || 'Hero'}" />
          <div class="match-info">
            <a href="https://www.opendota.com/matches/${m.match_id}" target="_blank">Match ${m.match_id}</a>
            <div class="meta">
              ${heroById[m.hero_id] || "Unknown Hero"} • ${fmtMins(m.duration)} • ${toDateStr(m.start_time)}
            </div>
            <div class="kda">K/D/A: ${m.kills}/${m.deaths}/${m.assists}</div>
          </div>
          <div>
            <div class="badge ${win ? 'win' : 'loss'}">${win ? 'Win' : 'Loss'}</div>
            <div class="side">${sideLabel(m.player_slot)}</div>
          </div>
        </li>
      `;
    }).join("");

    // Update counters
    $loadedCount.textContent = allMatches.length;
    $pageNum.textContent = page;

    // Keep the nice fade hint visible when scrolled to bottom
    // (optional tweak, no code needed because overlay is fixed)
  }

  // Load more flow
  async function loadMatches() {
    if (isLoading) return;
    isLoading = true;
    $loadMore.setAttribute("disabled", "true");
    const prevScrollHeight = $container.scrollHeight;

    // show skeletons
    showSkeletons(5);

    try {
      await fetchHeroesOnce();
      const chunk = await fetchMatchesChunk(offset);
      allMatches = allMatches.concat(chunk);
      offset += limit;
      page = 1 + Math.floor(offset / limit);
    } catch (e) {
      console.error("Failed to fetch:", e);
    } finally {
      // remove skeletons, render, re-enable
      clearSkeletons();
      render();
      $loadMore.removeAttribute("disabled");

      // Optional: keep scroll position anchored near previously loaded content
      if ($container.scrollTop < 40) {
        $container.scrollTop = prevScrollHeight - $container.clientHeight - 20;
      }
      isLoading = false;
    }
  }

  // Filters → re-render only (no fetch)
  $heroFilter.addEventListener("change", render);
  $resultFilter.addEventListener("change", render);

  // Button
  $loadMore.addEventListener("click", loadMatches);

  // Initial boot
  (async function init() {
    // First page
    await loadMatches();
  })();
</script>
</body>
</html>